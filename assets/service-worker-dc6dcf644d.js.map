{"version":3,"sources":["service-worker.js"],"names":["version","cacheName","cacheHostnames","staleHostnames","cacheExtensions","installDelayed","installCritical","fetchCacheOrNetwork","event","console","open","then","cache","response","match","fetch","request","log","url","fetchCacheOrNetworkSave","clone","put","fetchStaleWhileRevalidate","caches","fetchPromise","networkResponse","fetchNetworkSaveOrCache","fetchTimeoutNetworkSaveOrCache","responseCache","headerDate","headers","get","Date","getTime","diffDate","Promise","resolve","reject","setTimeout","race","responseNetwork","self","addEventListener","waitUntil","addAll","skipWaiting","cacheNames","cacheKey","startsWith","clients","claim","method","requestURL","URL","pathname","search","origin","location","requestExtension","test","value","versionFound","searchParams","forEach","key","indexOf","respondWith","i","length","hostname","split","pop"],"mappings":"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","file":"service-worker-dc6dcf644d.js","sourcesContent":["const version = 'v1::';\nconst cacheName = version + 'umalm';\nconst cacheHostnames = ['fonts.googleapis.com', 'fonts.gstatic.com'];\nconst staleHostnames = ['gravatar.com'];\nconst cacheExtensions = ['css', 'js', 'otf', 'eot', 'svg', 'ttf', 'woff', 'woff2', 'ico'];\nconst installDelayed = [\n    '/wp-content/themes/unemanettealamain/assets/logo/40x40.png',\n    '/wp-content/themes/unemanettealamain/assets/logo/150x150.png',\n    '/wp-content/themes/unemanettealamain/assets/logo/384x384.png'\n];\nconst installCritical = [];\n\n/**\n * This gives you the \"Cache only\" behaviour for things in the cache\n * and the \"Network only\" behaviour for anything not-cached\n * (which includes all non-GET requests, as they cannot be cached).\n * @see https://jakearchibald.com/2014/offline-cookbook/#cache-falling-back-to-network\n * @param event\n */\nconst fetchCacheOrNetwork = event => {\n    'use strict';\n\n    return caches.open(cacheName).then(cache => {\n        return cache.match(event.request).then(response => {\n            console.log('Service Worker - fetchCacheOrNetwork ' + (response ? '(cache)' : '(network)'), event.request.url);\n            return response || fetch(event.request);\n        });\n    });\n};\n\n/**\n * If a request doesn't match anything in the cache,\n * get it from the network, send it to the page\n * & add it to the cache at the same time.\n * @see https://jakearchibald.com/2014/offline-cookbook/#on-network-response\n * @param event\n */\nconst fetchCacheOrNetworkSave = event => {\n    'use strict';\n\n    return caches.open(cacheName).then(cache => {\n        return cache.match(event.request).then(response => {\n            console.log('Service Worker - fetchCacheOrNetworkSave ' + (response ? '(cache)' : '(network)'), event.request.url);\n            return response || fetch(event.request).then(response => {\n                cache.put(event.request, response.clone());\n                console.log('Service Worker - put into cache', event.request.url);\n                return response;\n            });\n        });\n    });\n};\n\n/**\n * If there's a cached version available, use it,\n * but fetch an update for next time.\n * @see https://jakearchibald.com/2014/offline-cookbook/#stale-while-revalidate\n * @param event\n */\nconst fetchStaleWhileRevalidate = event => {\n    'use strict';\n\n    return caches.open(cacheName).then(cache => {\n        return cache.match(event.request).then(response => {\n            let fetchPromise = fetch(event.request).then(networkResponse => {\n                cache.put(event.request, networkResponse.clone());\n                console.log('Service Worker - put into cache', event.request.url);\n                return networkResponse;\n            });\n            console.log('Service Worker - fetchStaleWhileRevalidate ' + (response ? '(cache)' : '(network)'), event.request.url);\n            return response || fetchPromise;\n        });\n    });\n};\n\n/**\n * Try to get a networked version, if successful\n * keep it in cache and return it. If not successful,\n * try to return a cached version if available.\n * @param event\n */\nconst fetchNetworkSaveOrCache = event => {\n    'use strict';\n\n    return caches.open(cacheName).then(cache => {\n        return fetch(event.request).then(response => {\n            cache.put(event.request, response.clone());\n            console.log('Service Worker - fetchNetworkSaveOrCache (network)', event.request.url);\n            console.log('Service Worker - put into cache', event.request.url);\n            return response;\n        }).catch(() => {\n            console.log('Service Worker - fetchNetworkSaveOrCache (cache)', event.request.url);\n            return cache.match(event.request);\n        });\n    });\n};\n\n/**\n * If a cache do not exists or is too older,\n * force a refresh with a newly network version\n * and fallback to cache.\n *\n * If a cache exists and is not too old,\n * try to get a networked version before timeout.\n * If successful keep it in cache and return it,\n * otherwise return provided fallback\n * @see https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Promise/race\n * @param event\n */\nconst fetchTimeoutNetworkSaveOrCache = event => {\n    'use strict';\n\n    return caches.open(cacheName).then(cache => {\n        return cache.match(event.request).then(responseCache => {\n            if (!responseCache) {\n                console.log('Service Worker - fetchTimeoutNetworkSaveOrCache --> no cache found', event.request.url);\n                return fetchNetworkSaveOrCache(event);\n            }\n\n            console.log('Service Worker - fetchTimeoutNetworkSaveOrCache --> cache found', event.request.url);\n            let headerDate = responseCache.headers.get('date');\n            if (!headerDate) {\n                console.log('Service Worker - fetchTimeoutNetworkSaveOrCache --> no header date found', event.request.url);\n                return fetchNetworkSaveOrCache(event);\n            }\n\n            let diffDate = ((new Date()).getTime() - (new Date(headerDate)).getTime());\n            if (!diffDate) {\n                console.log('Service Worker - fetchTimeoutNetworkSaveOrCache --> header date with empty time', headerDate, diffDate, event.request.url);\n                return fetchNetworkSaveOrCache(event);\n            }\n\n            if (diffDate > (3600 * 24 * 2 * 1000)) {\n                console.log('Service Worker - fetchTimeoutNetworkSaveOrCache --> header date > 2 days', headerDate, diffDate, event.request.url);\n                return fetchNetworkSaveOrCache(event);\n            }\n\n            console.log('Service Worker - fetchTimeoutNetworkSaveOrCache --> header date < 2 days', headerDate, diffDate, event.request.url);\n            return Promise.race([\n                new Promise((resolve, reject) => {\n                    setTimeout(reject, 5000);\n                }),\n                fetch(event.request)\n            ]).then(responseNetwork => {\n                console.log('Service Worker - fetchTimeoutNetworkSaveOrFallback (network)', event.request.url);\n                console.log('Service Worker - put into cache', event.request.url);\n                cache.put(event.request, responseNetwork.clone());\n                return responseNetwork;\n            }).catch(() => {\n                console.log('Service Worker - fetchTimeoutNetworkSaveOrFallback (cache)', event.request.url);\n                return responseCache;\n            });\n        });\n    });\n};\n\nself.addEventListener('install', event => {\n    'use strict';\n\n    console.log('Service Worker - Install');\n    event.waitUntil(\n        caches.open(cacheName).then(cache => {\n            console.log('Service Worker - Install files');\n            cache.addAll(installDelayed);\n            return cache.addAll(installCritical);\n        }).then(() => {\n            console.log('Service Worker - Install OK, skip waiting');\n            return self.skipWaiting();\n        })\n    );\n});\n\n/**\n * The activate event fires after a service worker has been successfully installed.\n * It is most useful when phasing out an older version of a service worker,\n * as at this point you know that the new worker was installed correctly.\n */\nself.addEventListener('activate', event => {\n    'use strict';\n\n    console.log('Service Worker - Activate');\n    event.waitUntil(\n        caches.keys().then(cacheNames => {\n            return Promise.all(cacheNames.filter(cacheKey => {\n                console.log('Activate - key -->', cacheKey);\n                return !cacheKey.startsWith(cacheName);\n            }).map(cacheKey => {\n                console.log('Service Worker - Delete key', cacheKey);\n                return caches.delete(cacheKey);\n            }));\n        })\n    );\n\n    return self.clients.claim();\n});\n\n/**\n * The fetch event fires whenever a page controlled by this service worker\n * requests a resource. This isn’t limited to fetch or even XMLHttpRequest.\n * Instead, it comprehends even the request for the HTML page on first load,\n * as well as JS and CSS resources, fonts, any images, etc.\n *\n * Note also that requests made against other origins will also be caught\n * by the fetch handler of the ServiceWorker.\n */\nself.addEventListener('fetch', event => {\n    'use strict';\n\n    /**\n     * We should only cache GET requests, and deal with the rest of method in the\n     * client-side, by handling failed POST,PUT,PATCH,etc. requests.\n     */\n    if (event.request.method !== 'GET') {\n        // If we don't block the event as shown below, then the request will go to the network as usual\n        console.log('Service Worker - Method is not GET, fetch event ignored.', event.request.method, event.request.url);\n        return;\n    }\n\n    // This service worker won't touch the admin area and preview pages\n    if (event.request.url.match(/wp-admin/) || event.request.url.match(/preview=true/)) {\n        console.log('Service worker - Admin page detected, fetch event ignored.', event.request.url);\n        return;\n    }\n\n    // parse the URL\n    let requestURL = new URL(event.request.url);\n    let requestExtension = requestURL.pathname.split('.').pop();\n\n    // If this is a local URL\n    if (requestURL.origin === location.origin) {\n        // search results must not be cached\n        if (requestURL.pathname === '/' && requestURL.search.startsWith('?s=')) {\n            console.log('Service Worker - Search results page detected, fetch event ignored.', event.request.url);\n            return;\n        }\n\n        if (cacheExtensions.indexOf(requestExtension) > -1) {\n            // serve local static files with version from cache\n            // fallback to network and save\n            if (/\\/unemanettealamain\\/assets\\/.*\\-[a-z0-9]+\\.[a-z0-9]+$/.test(requestURL.pathname)) {\n                console.log('Service Worker - Found local asset with version in pathname', event.request.url);\n                event.respondWith(fetchCacheOrNetworkSave(event));\n                return;\n            }\n\n            let versionFound = false;\n            requestURL.searchParams.forEach((value, key) => {\n                if (value !== '' && ['ver', 'v'].indexOf(key) > -1) {\n                    versionFound = true;\n                }\n            });\n\n            if (versionFound) {\n                console.log('Service Worker - Found local asset with version in query string', event.request.url);\n                event.respondWith(fetchCacheOrNetworkSave(event));\n                return;\n            }\n        }\n\n        // serve local page\n        if (/\\/$/.test(requestURL.pathname)) {\n            console.log('Service Worker - Found local static page', event.request.url);\n            event.respondWith(fetchTimeoutNetworkSaveOrCache(event));\n            return;\n        }\n    }\n\n    // Serve cache data for specific hosts\n    // fallback to network and save\n    let i;\n    for (i = 0; i < cacheHostnames.length; i++) {\n        if (requestURL.hostname.indexOf(cacheHostnames[i]) > -1) {\n            console.log('Service Worker - Found external static URL', event.request.url);\n            event.respondWith(fetchCacheOrNetworkSave(event));\n            return;\n        }\n    }\n\n    // Serve stale cache for specific hosts\n    for (i = 0; i < staleHostnames.length; i++) {\n        if (requestURL.hostname.indexOf(staleHostnames[i]) > -1) {\n            console.log('Service Worker - Found external static URL', event.request.url);\n            event.respondWith(fetchStaleWhileRevalidate(event));\n            return;\n        }\n    }\n\n    // Serve cache for specific extension and refresh cache\n    if (cacheExtensions.indexOf(requestURL.pathname.split('.').pop()) > -1) {\n        console.log('Service Worker - Found generic media extension', event.request.url);\n        event.respondWith(fetchStaleWhileRevalidate(event));\n        return;\n    }\n\n    // Generic fallback.\n    // Search into cache, fallback to network if not found.\n    // No data saved in cache when using network.\n    console.log('Service Worker - Generic fallback', event.request.url);\n    event.respondWith(fetchCacheOrNetwork(event));\n});\n"]}