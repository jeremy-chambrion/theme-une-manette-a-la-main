{"version":3,"sources":["service-worker.js"],"names":["version","cacheName","cacheHostnames","cacheExtensions","installFiles","fetchCacheOrNetwork","event","caches","match","request","then","response","console","log","url","fetch","fetchCacheOrNetworkSave","open","cache","put","clone","fetchStaleWhileRevalidate","fetchPromise","networkResponse","fetchNetworkSaveOrCache","catch","self","addEventListener","waitUntil","addAll","skipWaiting","keys","keyList","Promise","all","filter","key","startsWith","map","delete","clients","claim","method","requestURL","URL","requestExtension","pathname","split","pop","origin","location","indexOf","versionFound","searchParams","forEach","value","respondWith","test","i","length","hostname"],"mappings":"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","file":"service-worker-b87124d2a4.js","sourcesContent":["var version = 'v1::';\nvar cacheName = version + 'umalm';\nvar cacheHostnames = ['fonts.googleapis.com', 'fonts.gstatic.com', 'gravatar.com'];\nvar cacheExtensions = ['css', 'js', 'otf', 'eot', 'svg', 'ttf', 'woff', 'woff2', 'ico'];\nvar installFiles = [\n    '/wp-content/themes/unemanettealamain/assets/logo/40x40.png',\n    '/wp-content/themes/unemanettealamain/assets/logo/150x150.png',\n    '/wp-content/themes/unemanettealamain/assets/logo/384x384.png',\n    '/wp-content/themes/unemanettealamain/assets/logo/600x600.png'\n];\n\n/**\n * This gives you the \"Cache only\" behaviour for things in the cache\n * and the \"Network only\" behaviour for anything not-cached\n * (which includes all non-GET requests, as they cannot be cached).\n * @see https://jakearchibald.com/2014/offline-cookbook/#cache-falling-back-to-network\n */\nvar fetchCacheOrNetwork = function(event) {\n    'use strict';\n\n    return caches.match(event.request).then(function(response) {\n        console.log('Service Worker - fetchCacheOrNetwork ' + (response ? '(cache)' : '(network)'), event.request.url);\n        return response || fetch(event.request);\n    });\n};\n\n/**\n * If a request doesn't match anything in the cache,\n * get it from the network, send it to the page\n * & add it to the cache at the same time.\n * @see https://jakearchibald.com/2014/offline-cookbook/#on-network-response\n */\nvar fetchCacheOrNetworkSave = function(event) {\n    'use strict';\n\n    return caches.open(cacheName).then(function(cache) {\n        return cache.match(event.request).then(function(response) {\n            console.log('Service Worker - fetchCacheOrNetworkSave ' + (response ? '(cache)' : '(network)'), event.request.url);\n            return response || fetch(event.request).then(function(response) {\n                cache.put(event.request, response.clone());\n                console.log('Service Worker - put into cache', event.request.url);\n                return response;\n            });\n        });\n    });\n};\n\n/**\n * If there's a cached version available, use it,\n * but fetch an update for next time.\n * @see https://jakearchibald.com/2014/offline-cookbook/#stale-while-revalidate\n */\nvar fetchStaleWhileRevalidate = function(event) {\n    'use strict';\n\n    return caches.open(cacheName).then(function(cache) {\n        return cache.match(event.request).then(function(response) {\n            var fetchPromise = fetch(event.request).then(function(networkResponse) {\n                cache.put(event.request, networkResponse.clone());\n                console.log('Service Worker - put into cache', event.request.url);\n                return networkResponse;\n            });\n            console.log('Service Worker - fetchStaleWhileRevalidate ' + (response ? '(cache)' : '(network)'), event.request.url);\n            return response || fetchPromise;\n        });\n    });\n};\n\n/**\n * Try to get a networked version, if successful\n * keep it in cache and return it. If not successful,\n * try to return a cached version if available.\n */\nvar fetchNetworkSaveOrCache = function(event) {\n    'use strict';\n\n    return caches.open(cacheName).then(function(cache) {\n        return fetch(event.request).then(function(response) {\n            cache.put(event.request, response.clone());\n            console.log('Service Worker - fetchNetworkSaveOrCache (network)', event.request.url);\n            console.log('Service Worker - put into cache', event.request.url);\n            return response;\n        }).catch(function() {\n            console.log('Service Worker - fetchNetworkSaveOrCache (cache)', event.request.url);\n            return cache.match(event.request);\n        });\n    });\n};\n\n\nself.addEventListener('install', function(event) {\n    'use strict';\n\n    console.log('Service Worker - Install');\n    event.waitUntil(\n        caches.open(cacheName).then(function(cache) {\n            console.log('Service Worker - Install files');\n            return cache.addAll(installFiles);\n        })\n    );\n\n    return self.skipWaiting();\n});\n\n/**\n * The activate event fires after a service worker has been successfully installed.\n * It is most useful when phasing out an older version of a service worker,\n * as at this point you know that the new worker was installed correctly.\n */\nself.addEventListener('activate', function(event) {\n    'use strict';\n\n    console.log('Service Worker - Activate');\n    event.waitUntil(\n        caches.keys().then(function(keyList) {\n            return Promise.all(keyList.filter(function(key) {\n                return !key.startsWith(cacheName);\n            }).map(function(key) {\n                console.log('Service Worker - Delete key', key);\n                return caches.delete(key);\n            }));\n        }).then(function() {\n            console.log('Service Worker - Activate OK');\n        })\n    );\n\n    return self.clients.claim();\n});\n\n/**\n * The fetch event fires whenever a page controlled by this service worker\n * requests a resource. This isnâ€™t limited to fetch or even XMLHttpRequest.\n * Instead, it comprehends even the request for the HTML page on first load,\n * as well as JS and CSS resources, fonts, any images, etc.\n *\n * Note also that requests made against other origins will also be caught\n * by the fetch handler of the ServiceWorker.\n */\nself.addEventListener('fetch', function(event) {\n    'use strict';\n\n    /**\n     * We should only cache GET requests, and deal with the rest of method in the\n     * client-side, by handling failed POST,PUT,PATCH,etc. requests.\n     */\n    if (event.request.method !== 'GET') {\n        // If we don't block the event as shown below, then the request will go to the network as usual\n        console.log('Service Worker - Fetch event ignored.', event.request.method, event.request.url);\n        return;\n    }\n\n    // This service worker won't touch the admin area and preview pages\n    if (event.request.url.match(/wp-admin/) || event.request.url.match(/preview=true/)) {\n        console.log('Service worker - Fetch event ignored.', event.request.url);\n        return;\n    }\n\n    // parse the URL\n    var requestURL = new URL(event.request.url);\n    var requestExtension = requestURL.pathname.split('.').pop();\n\n    // If this is a local URL\n    if (requestURL.origin === location.origin) {\n        // serve js/css from cache and refresh cache if no version found\n        if (cacheExtensions.indexOf(requestExtension) > -1) {\n            var versionFound = false;\n            requestURL.searchParams.forEach(function(value, key) {\n                if (value !== '' && ['ver', 'v'].indexOf(key) > -1) {\n                    versionFound = true;\n                }\n            });\n\n            if (versionFound) {\n                console.log('Service Worker - Found local versioned CSS/JS', event.request.url);\n                event.respondWith(fetchCacheOrNetworkSave(event));\n                return;\n            }\n        }\n\n        // serve articles\n        /*\n        if (requestURL.pathname.startsWith('/article/')) {\n            console.log('Service Worker - Found article page', event.request.url);\n            event.respondWith(fetchStaleWhileRevalidate(event));\n            return;\n        }\n        */\n\n        // serve other static pages\n        if (/\\/$/.test(requestURL.pathname)) {\n            console.log('Service Worker - Found local static page', event.request.url);\n            event.respondWith(fetchNetworkSaveOrCache(event));\n            return;\n        }\n    }\n\n    // Serve cache data for specific hosts, fallback to network and save\n    for (var i = 0; i < cacheHostnames.length; i++) {\n        if (requestURL.hostname.indexOf(cacheHostnames[i]) > -1) {\n            console.log('Service Worker - Found external static URL', event.request.url);\n            event.respondWith(fetchCacheOrNetworkSave(event));\n            return;\n        }\n    }\n\n    // Serve cache for specific extension and refresh cache\n    if (cacheExtensions.indexOf(requestURL.pathname.split('.').pop()) > -1) {\n        console.log('Service Worker - Found generic media extension', event.request.url);\n        event.respondWith(fetchStaleWhileRevalidate(event));\n        return;\n    }\n\n    // Generic fallback.\n    // Search into cache, fallback to network if not found.\n    // No data saved in cache when using network.\n    console.log('Service Worker - Generic fallback', event.request.url);\n    event.respondWith(fetchCacheOrNetwork(event));\n});\n"]}