{"version":3,"sources":["service-worker.js"],"names":["version","cacheName","cacheHostnames","cacheExtensions","installDelayed","installCritical","fetchCacheOrNetwork","event","console","then","cache","response","fetch","request","log","url","fetchCacheOrNetworkSave","put","clone","fetchStaleWhileRevalidate","caches","fetchPromise","networkResponse","fetchNetworkSaveOrCache","catch","match","fetchTimeoutNetworkSaveOrCache","responseCache","headerDate","headers","get","Date","getTime","diffDate","setTimeout","resolve","reject","responseNetwork","self","skipWaiting","addAll","addEventListener","cacheKey","startsWith","waitUntil","keys","cacheNames","Promise","all","filter","clients","claim","map","delete","method","requestURL","URL","requestExtension","pathname","split","pop","origin","location","search","indexOf","test","versionFound","respondWith","value","key","i","hostname","length"],"mappings":"aAAA,IAAMA,QAAU,OACVC,UAAYD,QAAU,QADtBA,eAAN,CAAA,uBAAA,oBAAA,gBACMC,gBAAYD,CAAAA,MAAU,KAA5B,MAAA,MAAA,MAAA,MAAA,OAAA,QAAA,OACME,eAAkB,CAClBC,6DACAC,+DAKAC,gEAENA,gBAAA,GAOMC,oBAAsB,SAAAC,GAKhBC,OAAAA,OAAAA,KAAAP,WAAYQ,KAAA,SAAAC,GACZ,OAAAA,EAAOC,MAAAA,EAAYC,SAAML,KAAMM,SAAAA,GAHvC,OACIL,QAAAM,IAAA,yCAAAH,EAAA,UAAA,aAAAJ,EAAAM,QAAAE,KADJJ,GAAAC,MAAAL,EAAAM,cAeEG,wBAA0B,SAAAT,GAKpBC,OAAAA,OAAAA,KAAAP,WAAYQ,KAAA,SAAAC,GACZ,OAAAA,EAAOC,MAAAA,EAAYC,SAAML,KAAMM,SAAAA,GAE3BL,OADAE,QAAAA,IAAMO,6CAANN,EAAA,UAAA,aAAAJ,EAAAM,QAAAE,KACAP,GAAYI,MAAAL,EAAAM,SAAAJ,KAAA,SAAAE,GAJpB,OAKQD,EAAAO,IAAON,EAAPE,QAAAF,EAAAO,SAHJV,QAAAM,IAAA,kCAAAP,EAAAM,QAAAE,KAFJJ,SAiBFQ,0BAA4B,SAAAZ,GAKtB,OAAAa,OAAIC,KAAAA,WAAeT,KAAML,SAAAA,GACrBG,OAAAA,EAAAA,MAAUH,EAAMM,SAASS,KAAAA,SAAAA,GACzBd,IAAAA,EAAYI,MAAAL,EAAAM,SAAAJ,KAAA,SAAAa,GAGhBd,OAFIE,EAAAO,IAAOK,EAAAA,QAAPA,EAAAJ,SAHJV,QAAAM,IAAA,kCAAAP,EAAAM,QAAAE,KAKAO,IAPR,OACId,QAAAM,IAAA,+CAAAH,EAAA,UAAA,aAAAJ,EAAAM,QAAAE,KADJJ,GAAAU,OAmBEE,wBAA0B,SAAAhB,GAKpBG,OAAAA,OAAMO,KAAIV,WAAMM,KAASF,SAAAA,GACzBH,OAAAA,MAAQM,EAAID,SAAAJ,KAAA,SAAAE,GAIZH,OAHAA,EAAAA,IAAQM,EAAID,QAAAF,EAAAO,SACZV,QAAOG,IAAAA,qDAAPJ,EAAAM,QAAAE,KACDS,QAAMV,IAAA,kCAAMP,EAAAM,QAAAE,KACXP,IACAgB,MAAA,WARR,OACIhB,QAAAM,IAAA,mDAAAP,EAAAM,QAAAE,KADJL,EAAAe,MAAAlB,EAAAM,cAyBEa,+BAAiC,SAAAnB,GAK3B,OAAAa,OAAKO,KAAAA,WAAelB,KAAA,SAAAC,GAChBF,OAAAA,EAAAA,MAAAD,EAAYM,SAAAJ,KAAA,SAAAkB,GACZ,IAAAA,EAAA,OACHnB,QAAAM,IAAA,wEAAAP,EAAAM,QAAAE,KADUQ,wBAAwBhB,GAKnCC,QAAKoB,IAAAA,qEAAYrB,EAAAM,QAAAE,KACbP,IAAAA,EAAYmB,EAAAE,QAAAC,IAAA,QACZ,IAAAF,EAAA,OACHpB,QAAAM,IAAA,8EAAAP,EAAAM,QAAAE,KADUQ,wBAAwBhB,GAK/BC,IAAAA,GAAY,IAAAuB,MAAAC,UAAA,IAAAD,KAAAH,GAAAI,UACZ,OAAAC,EAKOV,OAAPU,GACHzB,QAAAM,IAAA,8EAAAc,EAAAK,EAAA1B,EAAAM,QAAAE,KADUQ,wBAAwBhB,KAM3B2B,QAAAA,IAAAA,8EAAAN,EAAAK,EAAA1B,EAAAM,QAAAE,KAEJH,QAAML,KAAMM,CAEZL,IAAAA,QAAY,SAAA2B,EAAAC,GACZ5B,WAAY4B,EAAA,OAEZxB,MAAAL,EAAO8B,WACRb,KAVI,SAAAa,GAzBX,OAoCQ7B,QAAQM,IAAI,+DAA8DP,EAAMM,QAAQE,KACxFP,QAAOmB,IAAAA,kCAAPpB,EAAAM,QAAAE,KAZJL,EAAAO,IAAAV,EAAAM,QAAAwB,EAAAnB,SAzBJmB,IADJb,MAAA,WAsCY,OAzChBhB,QAAAM,IAAA,6DAAAP,EAAAM,QAAAE,KAyCuBY,MApBVnB,QAAAM,IAAA,qFAAAc,EAAAK,EAAA1B,EAAAM,QAAAE,KADUQ,wBAAwBhB,SAiCnCC,KAAAA,iBAAY,UAAA,SAAAD,GAGfC,QAAOM,IAAA,4BACJN,EAAAA,UACAY,OAAOkB,KAAKC,WAAL9B,KAAP,SAAAC,GAHA,OAJRF,QAAAM,IAAA,kCAJJJ,EAAA8B,OAAApC,gBAQmBM,EAAM8B,OAAOnC,mBAQhCI,KAAA,WALY,OADAD,QAAQM,IAAI,6CACLwB,KAAKC,mBAkBRD,KAAAG,iBAAQC,WAASC,SAAAA,GAQ7B,OALYnC,QAAAM,IAAA,6BACHP,EANMqC,UAFfxB,OAAAyB,OAAApC,KAAA,SAAAqC,GAEQ,OAAOC,QAAQC,IAAIF,EAAWG,OAAO,SAAAP,GANjD,OAgBgBQ,QAAQC,IAAAA,wBAApBT,IAhBJA,EAAAC,WAAA1C,aASemD,IAAI,SAAAV,GAEH,OAQhBlC,QAAAM,IAAA,8BAAA4B,GARuBtB,OAAOiC,OAAOX,SAK1BJ,KAAKY,QAAQC,UAoBhBb,KAAAG,iBAAA,QAAA,SAAAlC,GAOAC,GAAY,QAAZA,EAAAA,QAAY8C,OADhB,GAAI/C,EAAMM,QAAQE,IAAIU,MAAM,aAAelB,EAAMM,QAAQE,IAAIU,MAAM,gBASnEjB,QAAAM,IAAA,6DAAAP,EAAAM,QAAAE,SATA,CAcQ,IAAAwC,EAAA,IAAAC,IAAAjD,EAAAM,QAAAE,KACH0C,EAAAF,EAAAG,SAAAC,MAAA,KAAAC,MAGG,GAAAL,EAAAM,SAAAC,SAAAD,OAAA,CAEA,GAAI,MAAJN,EAAIG,UAAAH,EAAAQ,OAAApB,WAAA,OAEApC,YADAC,QAAAA,IAAQM,sEAAmEP,EAAMM,QAAjFE,KAJR,IAAiD,EAA7CZ,gBAAgB6D,QAAQP,GAAwB,CAW5C,GAAA,yDAAoDQ,KAAAV,EAAAG,UADxD,OAEQQ,QAAAA,IAAAA,8DAAA3D,EAAAM,QAAAE,UACHR,EAAA4D,YAAAnD,wBAAAT,IAIDC,IAAAA,GAAY,EAOhB,GANID,EAAM4D,aAAYnD,QAAAA,SAAAA,EAAAA,GAClB,KAAAoD,IAAA,EAAA,CAAA,MAAA,KAAAJ,QAAAK,KACHH,GAAA,KAIDA,EAGA,OAFA1D,QAAYM,IAAA,kEAAZP,EAAAM,QAAAE,UACAR,EAAM4D,YAAYzC,wBAAAA,IAM1B,GAAA,MAAAuC,KAAAV,EAAAG,UAGQlD,OAFHA,QAAW8D,IAAIpE,2CAA4BK,EAAAM,QAAAE,UACxCwC,EAAAA,YAAWgB,+BAAsChE,IAOzD,IAAA,IAAA+D,EAAA,EAAAA,EAAApE,eAAAsE,OAAAF,IACInE,IAAwB,EAAxBA,EAAAA,SAAwBoD,QAAAA,eAAoBI,IAG5C,OAFAnD,QAAYM,IAAA,6CAAkDP,EAAMM,QAAQE,UAC5ER,EAAM4D,YAAYhD,wBAA0BZ,IAMhD,IAAA,EAAAJ,gBAAA6D,QAAAT,EAAAG,SAAAC,MAAA,KAAAC,OAjFJ,OAkFIpD,QAAYM,IAAA,iDAAZP,EAAAM,QAAAE,UACAR,EAAM4D,YAAY7D,0BAAlBC,IADAC,QAAQM,IAAI,oCAAqCP,EAAMM,QAAQE,KAC/DR,EAAM4D,YAAY7D,oBAAoBC,SAlErCC,QAAAM,IAAA,2DAAAP,EAAAM,QAAAyC,OAAA/C,EAAAM,QAAAE","file":"service-worker-6efa5a0d98.js","sourcesContent":["const version = 'v1::';\nconst cacheName = version + 'umalm';\nconst cacheHostnames = ['fonts.googleapis.com', 'fonts.gstatic.com', 'gravatar.com'];\nconst cacheExtensions = ['css', 'js', 'otf', 'eot', 'svg', 'ttf', 'woff', 'woff2', 'ico'];\nconst installDelayed = [\n    '/wp-content/themes/unemanettealamain/assets/logo/40x40.png',\n    '/wp-content/themes/unemanettealamain/assets/logo/150x150.png',\n    '/wp-content/themes/unemanettealamain/assets/logo/384x384.png'\n];\nconst installCritical = [];\n\n/**\n * This gives you the \"Cache only\" behaviour for things in the cache\n * and the \"Network only\" behaviour for anything not-cached\n * (which includes all non-GET requests, as they cannot be cached).\n * @see https://jakearchibald.com/2014/offline-cookbook/#cache-falling-back-to-network\n * @param event\n */\nconst fetchCacheOrNetwork = event => {\n    'use strict';\n\n    return caches.open(cacheName).then(cache => {\n        return cache.match(event.request).then(response => {\n            console.log('Service Worker - fetchCacheOrNetwork ' + (response ? '(cache)' : '(network)'), event.request.url);\n            return response || fetch(event.request);\n        });\n    });\n};\n\n/**\n * If a request doesn't match anything in the cache,\n * get it from the network, send it to the page\n * & add it to the cache at the same time.\n * @see https://jakearchibald.com/2014/offline-cookbook/#on-network-response\n * @param event\n */\nconst fetchCacheOrNetworkSave = event => {\n    'use strict';\n\n    return caches.open(cacheName).then(cache => {\n        return cache.match(event.request).then(response => {\n            console.log('Service Worker - fetchCacheOrNetworkSave ' + (response ? '(cache)' : '(network)'), event.request.url);\n            return response || fetch(event.request).then(response => {\n                cache.put(event.request, response.clone());\n                console.log('Service Worker - put into cache', event.request.url);\n                return response;\n            });\n        });\n    });\n};\n\n/**\n * If there's a cached version available, use it,\n * but fetch an update for next time.\n * @see https://jakearchibald.com/2014/offline-cookbook/#stale-while-revalidate\n * @param event\n */\nconst fetchStaleWhileRevalidate = event => {\n    'use strict';\n\n    return caches.open(cacheName).then(cache => {\n        return cache.match(event.request).then(response => {\n            let fetchPromise = fetch(event.request).then(networkResponse => {\n                cache.put(event.request, networkResponse.clone());\n                console.log('Service Worker - put into cache', event.request.url);\n                return networkResponse;\n            });\n            console.log('Service Worker - fetchStaleWhileRevalidate ' + (response ? '(cache)' : '(network)'), event.request.url);\n            return response || fetchPromise;\n        });\n    });\n};\n\n/**\n * Try to get a networked version, if successful\n * keep it in cache and return it. If not successful,\n * try to return a cached version if available.\n * @param event\n */\nconst fetchNetworkSaveOrCache = event => {\n    'use strict';\n\n    return caches.open(cacheName).then(cache => {\n        return fetch(event.request).then(response => {\n            cache.put(event.request, response.clone());\n            console.log('Service Worker - fetchNetworkSaveOrCache (network)', event.request.url);\n            console.log('Service Worker - put into cache', event.request.url);\n            return response;\n        }).catch(() => {\n            console.log('Service Worker - fetchNetworkSaveOrCache (cache)', event.request.url);\n            return cache.match(event.request);\n        });\n    });\n};\n\n/**\n * If a cache do not exists or is too older,\n * force a refresh with a newly network version\n * and fallback to cache.\n *\n * If a cache exists and is not too old,\n * try to get a networked version before timeout.\n * If successful keep it in cache and return it,\n * otherwise return provided fallback\n * @see https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Promise/race\n * @param event\n */\nconst fetchTimeoutNetworkSaveOrCache = event => {\n    'use strict';\n\n    return caches.open(cacheName).then(cache => {\n        return cache.match(event.request).then(responseCache => {\n            if (!responseCache) {\n                console.log('Service Worker - fetchTimeoutNetworkSaveOrCache --> no cache found', event.request.url);\n                return fetchNetworkSaveOrCache(event);\n            }\n\n            console.log('Service Worker - fetchTimeoutNetworkSaveOrCache --> cache found', event.request.url);\n            let headerDate = responseCache.headers.get('date');\n            if (!headerDate) {\n                console.log('Service Worker - fetchTimeoutNetworkSaveOrCache --> no header date found', event.request.url);\n                return fetchNetworkSaveOrCache(event);\n            }\n\n            let diffDate = ((new Date()).getTime() - (new Date(headerDate)).getTime());\n            if (!diffDate) {\n                console.log('Service Worker - fetchTimeoutNetworkSaveOrCache --> header date with empty time', headerDate, diffDate, event.request.url);\n                return fetchNetworkSaveOrCache(event);\n            }\n\n            if (diffDate > (3600 * 24 * 2 * 1000)) {\n                console.log('Service Worker - fetchTimeoutNetworkSaveOrCache --> header date > 2 days', headerDate, diffDate, event.request.url);\n                return fetchNetworkSaveOrCache(event);\n            }\n\n            console.log('Service Worker - fetchTimeoutNetworkSaveOrCache --> header date < 2 days', headerDate, diffDate, event.request.url);\n            return Promise.race([\n                new Promise((resolve, reject) => {\n                    setTimeout(reject, 5000);\n                }),\n                fetch(event.request)\n            ]).then(responseNetwork => {\n                console.log('Service Worker - fetchTimeoutNetworkSaveOrFallback (network)', event.request.url);\n                console.log('Service Worker - put into cache', event.request.url);\n                cache.put(event.request, responseNetwork.clone());\n                return responseNetwork;\n            }).catch(() => {\n                console.log('Service Worker - fetchTimeoutNetworkSaveOrFallback (cache)', event.request.url);\n                return responseCache;\n            });\n        });\n    });\n};\n\nself.addEventListener('install', event => {\n    'use strict';\n\n    console.log('Service Worker - Install');\n    event.waitUntil(\n        caches.open(cacheName).then(cache => {\n            console.log('Service Worker - Install files');\n            cache.addAll(installDelayed);\n            return cache.addAll(installCritical);\n        }).then(() => {\n            console.log('Service Worker - Install OK, skip waiting');\n            return self.skipWaiting();\n        })\n    );\n});\n\n/**\n * The activate event fires after a service worker has been successfully installed.\n * It is most useful when phasing out an older version of a service worker,\n * as at this point you know that the new worker was installed correctly.\n */\nself.addEventListener('activate', event => {\n    'use strict';\n\n    console.log('Service Worker - Activate');\n    event.waitUntil(\n        caches.keys().then(cacheNames => {\n            return Promise.all(cacheNames.filter(cacheKey => {\n                console.log('Activate - key -->', cacheKey);\n                return !cacheKey.startsWith(cacheName);\n            }).map(cacheKey => {\n                console.log('Service Worker - Delete key', cacheKey);\n                return caches.delete(cacheKey);\n            }));\n        })\n    );\n\n    return self.clients.claim();\n});\n\n/**\n * The fetch event fires whenever a page controlled by this service worker\n * requests a resource. This isn’t limited to fetch or even XMLHttpRequest.\n * Instead, it comprehends even the request for the HTML page on first load,\n * as well as JS and CSS resources, fonts, any images, etc.\n *\n * Note also that requests made against other origins will also be caught\n * by the fetch handler of the ServiceWorker.\n */\nself.addEventListener('fetch', event => {\n    'use strict';\n\n    /**\n     * We should only cache GET requests, and deal with the rest of method in the\n     * client-side, by handling failed POST,PUT,PATCH,etc. requests.\n     */\n    if (event.request.method !== 'GET') {\n        // If we don't block the event as shown below, then the request will go to the network as usual\n        console.log('Service Worker - Method is not GET, fetch event ignored.', event.request.method, event.request.url);\n        return;\n    }\n\n    // This service worker won't touch the admin area and preview pages\n    if (event.request.url.match(/wp-admin/) || event.request.url.match(/preview=true/)) {\n        console.log('Service worker - Admin page detected, fetch event ignored.', event.request.url);\n        return;\n    }\n\n    // parse the URL\n    let requestURL = new URL(event.request.url);\n    let requestExtension = requestURL.pathname.split('.').pop();\n\n    // If this is a local URL\n    if (requestURL.origin === location.origin) {\n        // search results must not be cached\n        if (requestURL.pathname === '/' && requestURL.search.startsWith('?s=')) {\n            console.log('Service Worker - Search results page detected, fetch event ignored.', event.request.url);\n            return;\n        }\n\n        if (cacheExtensions.indexOf(requestExtension) > -1) {\n            // serve local static files with version from cache\n            // fallback to network and save\n            if (/\\/unemanettealamain\\/assets\\/.*\\-[a-z0-9]+\\.[a-z0-9]+$/.test(requestURL.pathname)) {\n                console.log('Service Worker - Found local asset with version in pathname', event.request.url);\n                event.respondWith(fetchCacheOrNetworkSave(event));\n                return;\n            }\n\n            let versionFound = false;\n            requestURL.searchParams.forEach((value, key) => {\n                if (value !== '' && ['ver', 'v'].indexOf(key) > -1) {\n                    versionFound = true;\n                }\n            });\n\n            if (versionFound) {\n                console.log('Service Worker - Found local asset with version in query string', event.request.url);\n                event.respondWith(fetchCacheOrNetworkSave(event));\n                return;\n            }\n        }\n\n        // serve local page\n        if (/\\/$/.test(requestURL.pathname)) {\n            console.log('Service Worker - Found local static page', event.request.url);\n            event.respondWith(fetchTimeoutNetworkSaveOrCache(event));\n            return;\n        }\n    }\n\n    // Serve cache data for specific hosts\n    // fallback to network and save\n    for (let i = 0; i < cacheHostnames.length; i++) {\n        if (requestURL.hostname.indexOf(cacheHostnames[i]) > -1) {\n            console.log('Service Worker - Found external static URL', event.request.url);\n            event.respondWith(fetchCacheOrNetworkSave(event));\n            return;\n        }\n    }\n\n    // Serve cache for specific extension and refresh cache\n    if (cacheExtensions.indexOf(requestURL.pathname.split('.').pop()) > -1) {\n        console.log('Service Worker - Found generic media extension', event.request.url);\n        event.respondWith(fetchStaleWhileRevalidate(event));\n        return;\n    }\n\n    // Generic fallback.\n    // Search into cache, fallback to network if not found.\n    // No data saved in cache when using network.\n    console.log('Service Worker - Generic fallback', event.request.url);\n    event.respondWith(fetchCacheOrNetwork(event));\n});\n"]}