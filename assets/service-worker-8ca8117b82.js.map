{"version":3,"sources":["service-worker.js"],"names":["version","cacheName","cacheHostnames","cacheExtensions","installDelayed","installCritical","fetchCacheOrNetwork","caches","open","response","fetch","event","cache","match","request","then","console","log","url","fetchCacheOrNetworkSave","put","clone","fetchStaleWhileRevalidate","fetchPromise","networkResponse","fetchNetworkSaveOrCache","catch","fetchTimeoutNetworkSaveOrCache","responseCache","headerDate","diffDate","Date","getTime","race","resolve","reject","responseNetwork","addEventListener","waitUntil","addAll","self","skipWaiting","keys","cacheNames","clients","claim","filter","cacheKey","startsWith","map","delete","method","requestURL","origin","URL","requestExtension","pathname","split","pop","location","search","respondWith","versionFound","test","searchParams","forEach","value","key","indexOf","i","hostname"],"mappings":"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","file":"service-worker-8ca8117b82.js","sourcesContent":["const version = 'v1::';\nconst cacheName = version + 'umalm';\nconst cacheHostnames = ['fonts.googleapis.com', 'fonts.gstatic.com', 'gravatar.com'];\nconst cacheExtensions = ['css', 'js', 'otf', 'eot', 'svg', 'ttf', 'woff', 'woff2', 'ico'];\nconst installDelayed = [\n    '/wp-content/themes/unemanettealamain/assets/logo/40x40.png',\n    '/wp-content/themes/unemanettealamain/assets/logo/150x150.png',\n    '/wp-content/themes/unemanettealamain/assets/logo/384x384.png',\n    '/wp-content/themes/unemanettealamain/assets/logo/600x600.png'\n];\nconst installCritical = [];\n\n/**\n * This gives you the \"Cache only\" behaviour for things in the cache\n * and the \"Network only\" behaviour for anything not-cached\n * (which includes all non-GET requests, as they cannot be cached).\n * @see https://jakearchibald.com/2014/offline-cookbook/#cache-falling-back-to-network\n * @param event\n */\nconst fetchCacheOrNetwork = event => {\n    'use strict';\n\n    return caches.open(cacheName).then(cache => {\n        return cache.match(event.request).then(response => {\n            console.log('Service Worker - fetchCacheOrNetwork ' + (response ? '(cache)' : '(network)'), event.request.url);\n            return response || fetch(event.request);\n        });\n    });\n};\n\n/**\n * If a request doesn't match anything in the cache,\n * get it from the network, send it to the page\n * & add it to the cache at the same time.\n * @see https://jakearchibald.com/2014/offline-cookbook/#on-network-response\n * @param event\n */\nconst fetchCacheOrNetworkSave = event => {\n    'use strict';\n\n    return caches.open(cacheName).then(cache => {\n        return cache.match(event.request).then(response => {\n            console.log('Service Worker - fetchCacheOrNetworkSave ' + (response ? '(cache)' : '(network)'), event.request.url);\n            return response || fetch(event.request).then(response => {\n                cache.put(event.request, response.clone());\n                console.log('Service Worker - put into cache', event.request.url);\n                return response;\n            });\n        });\n    });\n};\n\n/**\n * If there's a cached version available, use it,\n * but fetch an update for next time.\n * @see https://jakearchibald.com/2014/offline-cookbook/#stale-while-revalidate\n * @param event\n */\nconst fetchStaleWhileRevalidate = event => {\n    'use strict';\n\n    return caches.open(cacheName).then(cache => {\n        return cache.match(event.request).then(response => {\n            let fetchPromise = fetch(event.request).then(networkResponse => {\n                cache.put(event.request, networkResponse.clone());\n                console.log('Service Worker - put into cache', event.request.url);\n                return networkResponse;\n            });\n            console.log('Service Worker - fetchStaleWhileRevalidate ' + (response ? '(cache)' : '(network)'), event.request.url);\n            return response || fetchPromise;\n        });\n    });\n};\n\n/**\n * Try to get a networked version, if successful\n * keep it in cache and return it. If not successful,\n * try to return a cached version if available.\n * @param event\n */\nconst fetchNetworkSaveOrCache = event => {\n    'use strict';\n\n    return caches.open(cacheName).then(cache => {\n        return fetch(event.request).then(response => {\n            cache.put(event.request, response.clone());\n            console.log('Service Worker - fetchNetworkSaveOrCache (network)', event.request.url);\n            console.log('Service Worker - put into cache', event.request.url);\n            return response;\n        }).catch(() => {\n            console.log('Service Worker - fetchNetworkSaveOrCache (cache)', event.request.url);\n            return cache.match(event.request);\n        });\n    });\n};\n\n/**\n * If a cache do not exists or is too older,\n * force a refresh with a newly network version\n * and fallback to cache.\n *\n * If a cache exists and is not too old,\n * try to get a networked version before timeout.\n * If successful keep it in cache and return it,\n * otherwise return provided fallback\n * @see https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Promise/race\n * @param event\n */\nconst fetchTimeoutNetworkSaveOrCache = event => {\n    'use strict';\n\n    return caches.open(cacheName).then(cache => {\n        return cache.match(event.request).then(responseCache => {\n            if (!responseCache) {\n                console.log('Service Worker - fetchTimeoutNetworkSaveOrCache --> no cache found', event.request.url);\n                return fetchNetworkSaveOrCache(event);\n            }\n\n            console.log('Service Worker - fetchTimeoutNetworkSaveOrCache --> cache found', event.request.url);\n            let headerDate = responseCache.headers.get('date');\n            if (!headerDate) {\n                console.log('Service Worker - fetchTimeoutNetworkSaveOrCache --> no header date found', event.request.url);\n                return fetchNetworkSaveOrCache(event);\n            }\n\n            let diffDate = ((new Date()).getTime() - (new Date(headerDate)).getTime());\n            if (!diffDate) {\n                console.log('Service Worker - fetchTimeoutNetworkSaveOrCache --> header date with empty time', headerDate, diffDate, event.request.url);\n                return fetchNetworkSaveOrCache(event);\n            }\n\n            if (diffDate > (3600 * 24 * 2 * 1000)) {\n                console.log('Service Worker - fetchTimeoutNetworkSaveOrCache --> header date > 2 days', headerDate, diffDate, event.request.url);\n                return fetchNetworkSaveOrCache(event);\n            }\n\n            console.log('Service Worker - fetchTimeoutNetworkSaveOrCache --> header date < 2 days', headerDate, diffDate, event.request.url);\n            return Promise.race([\n                new Promise((resolve, reject) => {\n                    setTimeout(reject, 5000);\n                }),\n                fetch(event.request)\n            ]).then(responseNetwork => {\n                console.log('Service Worker - fetchTimeoutNetworkSaveOrFallback (network)', event.request.url);\n                console.log('Service Worker - put into cache', event.request.url);\n                cache.put(event.request, responseNetwork.clone());\n                return responseNetwork;\n            }).catch(() => {\n                console.log('Service Worker - fetchTimeoutNetworkSaveOrFallback (cache)', event.request.url);\n                return responseCache;\n            });\n        });\n    });\n};\n\nself.addEventListener('install', event => {\n    'use strict';\n\n    console.log('Service Worker - Install');\n    event.waitUntil(\n        caches.open(cacheName).then(cache => {\n            console.log('Service Worker - Install files');\n            cache.addAll(installDelayed);\n            return cache.addAll(installCritical);\n        }).then(() => {\n            console.log('Service Worker - Install OK, skip waiting');\n            return self.skipWaiting();\n        })\n    );\n});\n\n/**\n * The activate event fires after a service worker has been successfully installed.\n * It is most useful when phasing out an older version of a service worker,\n * as at this point you know that the new worker was installed correctly.\n */\nself.addEventListener('activate', event => {\n    'use strict';\n\n    console.log('Service Worker - Activate');\n    event.waitUntil(\n        caches.keys().then(cacheNames => {\n            return Promise.all(cacheNames.filter(cacheKey => {\n                console.log('Activate - key -->', cacheKey);\n                return !cacheKey.startsWith(cacheName);\n            }).map(cacheKey => {\n                console.log('Service Worker - Delete key', cacheKey);\n                return caches.delete(cacheKey);\n            }));\n        })\n    );\n\n    return self.clients.claim();\n});\n\n/**\n * The fetch event fires whenever a page controlled by this service worker\n * requests a resource. This isn’t limited to fetch or even XMLHttpRequest.\n * Instead, it comprehends even the request for the HTML page on first load,\n * as well as JS and CSS resources, fonts, any images, etc.\n *\n * Note also that requests made against other origins will also be caught\n * by the fetch handler of the ServiceWorker.\n */\nself.addEventListener('fetch', event => {\n    'use strict';\n\n    /**\n     * We should only cache GET requests, and deal with the rest of method in the\n     * client-side, by handling failed POST,PUT,PATCH,etc. requests.\n     */\n    if (event.request.method !== 'GET') {\n        // If we don't block the event as shown below, then the request will go to the network as usual\n        console.log('Service Worker - Method is not GET, fetch event ignored.', event.request.method, event.request.url);\n        return;\n    }\n\n    // This service worker won't touch the admin area and preview pages\n    if (event.request.url.match(/wp-admin/) || event.request.url.match(/preview=true/)) {\n        console.log('Service worker - Admin page detected, fetch event ignored.', event.request.url);\n        return;\n    }\n\n    // parse the URL\n    let requestURL = new URL(event.request.url);\n    let requestExtension = requestURL.pathname.split('.').pop();\n\n    // If this is a local URL\n    if (requestURL.origin === location.origin) {\n        // search results must not be cached\n        if (requestURL.pathname === '/' && requestURL.search.startsWith('?s=')) {\n            console.log('Service Worker - Search results page detected, fetch event ignored.', event.request.url);\n            return;\n        }\n\n        if (cacheExtensions.indexOf(requestExtension) > -1) {\n            // serve local static files with version from cache\n            // fallback to network and save\n            if (/\\/unemanettealamain\\/assets\\/.*\\-[a-z0-9]+\\.[a-z0-9]+$/.test(requestURL.pathname)) {\n                console.log('Service Worker - Found local asset with version in pathname', event.request.url);\n                event.respondWith(fetchCacheOrNetworkSave(event));\n                return;\n            }\n\n            let versionFound = false;\n            requestURL.searchParams.forEach((value, key) => {\n                if (value !== '' && ['ver', 'v'].indexOf(key) > -1) {\n                    versionFound = true;\n                }\n            });\n\n            if (versionFound) {\n                console.log('Service Worker - Found local asset with version in query string', event.request.url);\n                event.respondWith(fetchCacheOrNetworkSave(event));\n                return;\n            }\n        }\n\n        // serve local page\n        if (/\\/$/.test(requestURL.pathname)) {\n            console.log('Service Worker - Found local static page', event.request.url);\n            event.respondWith(fetchTimeoutNetworkSaveOrCache(event));\n            return;\n        }\n    }\n\n    // Serve cache data for specific hosts\n    // fallback to network and save\n    for (let i = 0; i < cacheHostnames.length; i++) {\n        if (requestURL.hostname.indexOf(cacheHostnames[i]) > -1) {\n            console.log('Service Worker - Found external static URL', event.request.url);\n            event.respondWith(fetchCacheOrNetworkSave(event));\n            return;\n        }\n    }\n\n    // Serve cache for specific extension and refresh cache\n    if (cacheExtensions.indexOf(requestURL.pathname.split('.').pop()) > -1) {\n        console.log('Service Worker - Found generic media extension', event.request.url);\n        event.respondWith(fetchStaleWhileRevalidate(event));\n        return;\n    }\n\n    // Generic fallback.\n    // Search into cache, fallback to network if not found.\n    // No data saved in cache when using network.\n    console.log('Service Worker - Generic fallback', event.request.url);\n    event.respondWith(fetchCacheOrNetwork(event));\n});\n"]}